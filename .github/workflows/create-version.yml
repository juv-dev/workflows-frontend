on:
  workflow_call:
    # No inputs obligatorios; el workflow lee el contexto del repositorio/PR del repo que lo llama.
    inputs: {}

jobs:
  bump-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Check if PR is from the same repo (skip forks)
        id: repo_check
        uses: actions/github-script@v7
        with:
          script: |
            // En workflows reutilizables, context se refiere al repo que llama.
            const headRepo = context.payload.pull_request?.head?.repo?.full_name || '';
            const baseRepo = context.repo.owner + '/' + context.repo.repo;
            return (headRepo === baseRepo).toString();

      - name: Stop for forked PRs
        if: steps.repo_check.outputs.result != 'true'
        run: |
          echo "PR comes from a forked repo — this workflow cannot push to fork branches. Skipping."

      - name: Checkout PR branch
        if: steps.repo_check.outputs.result == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        if: steps.repo_check.outputs.result == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Determine bump type from PR commits (feat -> minor, fix -> patch)
        if: steps.repo_check.outputs.result == 'true'
        id: bump
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) return 'none';
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const hasFeat = commits.some(c => {
              const m = c.commit && c.commit.message ? c.commit.message : '';
              return /^feat(\(|:|\b)/i.test(m);
            });
            const hasFix = commits.some(c => {
              const m = c.commit && c.commit.message ? c.commit.message : '';
              return /^fix(\(|:|\b)/i.test(m);
            });
            if (hasFeat) return 'minor';
            if (hasFix) return 'patch';
            return 'none';

      - name: Exit if no bump needed
        if: steps.repo_check.outputs.result == 'true' && steps.bump.outputs.result == 'none'
        run: |
          echo "No feat or fix commits in PR — no version bump required."

      - name: Avoid loop: skip if last commit is the bot bump commit
        if: steps.repo_check.outputs.result == 'true' && steps.bump.outputs.result != 'none'
        run: |
          LAST_AUTHOR_EMAIL=$(git --no-pager log -1 --pretty=format:'%ae' || echo "")
          echo "last author: $LAST_AUTHOR_EMAIL"
          if [ "$LAST_AUTHOR_EMAIL" = "41898282+github-actions[bot]@users.noreply.github.com" ]; then
            echo "Last commit authored by the actions bot — likely our previous bump. Skipping to avoid loop."
            exit 0
          fi

      - name: Compute new version and update package.json
        if: steps.repo_check.outputs.result == 'true' && steps.bump.outputs.result != 'none'
        id: update
        run: |
          set -euo pipefail
          BUMP="${{ steps.bump.outputs.result }}"
          echo "Bump type: $BUMP"

          if [ ! -f package.json ]; then
            echo "package.json not found — cannot bump version."
            echo "new_version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          CURRENT=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT"

          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
          MAJOR=${MAJOR:-0}; MINOR=${MINOR:-0}; PATCH=${PATCH:-0}

          if [ "$BUMP" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW"

          if [ "$NEW" = "$CURRENT" ]; then
            echo "package.json already has version $NEW — nothing to do."
            echo "new_version=$NEW" >> $GITHUB_OUTPUT
            exit 0
          fi

          node -e "const fs=require('fs');const p=require('./package.json');p.version='$NEW';fs.writeFileSync('package.json',JSON.stringify(p,null,2)+'\n')"

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add package.json
          git commit -m "feat(main): bump version to v$NEW [skip ci]"

          # push back to the PR branch (uses persisted credentials from the caller workflow)
          git push --set-upstream origin HEAD

          echo "new_version=$NEW" >> $GITHUB_OUTPUT

      - name: Comment PR about bump
        if: steps.repo_check.outputs.result == 'true' && steps.update.outputs.new_version
        uses: actions/github-script@v7
        with:
          script: |
            const v = `${{ steps.update.outputs.new_version }}`;
            const pr = context.payload.pull_request?.number;
            if (pr) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr,
                body: `Auto bumped package.json version to ${v} (based on commits in this PR).`
              });
            }